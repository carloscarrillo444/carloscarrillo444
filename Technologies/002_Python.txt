SCRIPTS RELATED
Projects related to Python language
python3
pycharm-ide
notebook-jupyter
devops


##### INHERITANCE
class Book(object, metaclass=ABCMeta):
    def __init__(self,title,author):
        self.title=title
        self.author=author   
    @abstractmethod
    def display(): pass

    
#Write MyBook class
class MyBook(Book):
    def __init__(self, title, author, price):
        self.title = title
        self.author = author
        self.price = price
    def display(self):
        print("Title: " + self.title)
        print("Author: " + self.author)
        print("Price: " + str(self.price))  

title=input()
author=input()
price=int(input())
new_novel=MyBook(title,author,price)
new_novel.display()


#############
x = txt.isnumeric()  ## DEVUELVE UN FALSE or TRUE

## QUEUE STRUCTURE
        class Queue:
            def __init__(self):
                self.items = []

            def isEmpty(self):
                return self.items == []

            def enqueue(self, item):
                self.items.insert(0,item)

            def dequeue(self):
                return self.items.pop()

            def size(self):
                return len(self.items)
                
## STACK STRCUTURE

        class Stack:
             def __init__(self):
                 self.items = []

             def isEmpty(self):
                 return self.items == []

             def push(self, item):
                 self.items.append(item)

             def pop(self):
                 return self.items.pop()

             def peek(self):
                 return self.items[len(self.items)-1]

             def size(self):
                 return len(self.items)
                 
 ## BINARY TREE STRCUTURE
             #!/usr/bin/python

            class Node:
                def __init__(self, val):
                    self.l = None
                    self.r = None
                    self.v = val

            class Tree:
                def __init__(self):
                    self.root = None

                def getRoot(self):
                    return self.root

                def add(self, val):
                    if self.root is None:
                        self.root = Node(val)
                    else:
                        self._add(val, self.root)

                def _add(self, val, node):
                    if val < node.v:
                        if node.l is not None:
                            self._add(val, node.l)
                        else:
                            node.l = Node(val)
                    else:
                        if node.r is not None:
                            self._add(val, node.r)
                        else:
                            node.r = Node(val)

                def find(self, val):
                    if self.root is not None:
                        return self._find(val, self.root)
                    else:
                        return None

                def _find(self, val, node):
                    if val == node.v:
                        return node
                    elif (val < node.v and node.l is not None):
                        return self._find(val, node.l)
                    elif (val > node.v and node.r is not None):
                        return self._find(val, node.r)

                def deleteTree(self):
                    # garbage collector will do this for us. 
                    self.root = None

                def printTree(self):
                    if self.root is not None:
                        self._printTree(self.root)

                def _printTree(self, node):
                    if node is not None:
                        self._printTree(node.l)
                        print(str(node.v) + ' ')
                        self._printTree(node.r)

            #     3
            # 0     4
            #   2      8
            tree = Tree()
            tree.add(3)
            tree.add(4)
            tree.add(0)
            tree.add(8)
            tree.add(2)
            tree.printTree()
            print(tree.find(3).v)
            print(tree.find(10))
            tree.deleteTree()
            tree.printTree()




############# DAY 15: LISTED LISTED
            class Node:
                def __init__(self,data):
                    self.data = data
                    self.next = None 
            class Solution: 
                def display(self,head):
                    current = head
                    while current:
                        print(current.data,end=' ')
                        current = current.next

                def insert(self,head,data):
                #Complete this method
                    node = Node(data)
                    if head==None :
                        return node
                    else :
                        currentNode=head;
                        while currentNode.next != None :
                            currentNode=currentNode.next;
                        currentNode.next=node
                        return head

            mylist= Solution()
            T=int(input())
            head=None
            for i in range(T):
                data=int(input())
                head=mylist.insert(head,data)    
            mylist.display(head); 	  

############# DAY 16: EXCEPTIONS

            except (RuntimeError, TypeError, NameError):
            import sys

            try:
                f = open('myfile.txt')
                s = f.readline()
                i = int(s.strip())
            except OSError as err:  ## INPUT
                print("OS error: {0}".format(err))
            except ValueError:  ##CONVERTING
                print("Could not convert data to an integer.")
            except ZeroDivisionError as err: #MATHEMATICS
            except:
                print("Unexpected error:", sys.exc_info()[0])
                raise
                except TyeError #unsupported operand type(s) for /: 'str' and 'str'
    
    
###### Day 18: Queues and Stacks
    
                    import sys

                class Solution:
                    # Write your code here
                    def __init__(self):
                        self.top = 0
                        self.rear = 0
                        self.a = list()
                        self.r = list()

                    def pushCharacter(self, char):  # stack
                        self.a.append(char)
                        self.top += 1

                    def popCharacter(self):         # stack
                        self.top -= 1
                        return self.a[self.top]

                    def enqueueCharacter(self, char): # QUeue
                        self.r.append(char)
                        self.rear += 1
                        
                    def dequeueCharacter(self):         # QUeue
                        return self.r[i]

                # read the string s
                s=input()
                #Create the Solution class object
                obj=Solution()   

                l=len(s)
                # push/enqueue all the characters of string s to stack
                for i in range(l):
                    obj.pushCharacter(s[i])
                    obj.enqueueCharacter(s[i])
                    
                isPalindrome=True
                '''
                pop the top character from stack
                dequeue the first character from queue
                compare both the characters
                ''' 
                for i in range(l // 2):
                    if obj.popCharacter()!=obj.dequeueCharacter():
                        isPalindrome=False
                        break
                #finally print whether string s is palindrome or not.
                if isPalindrome:
                    print("The word, "+s+", is a palindrome.")
                else:
                    print("The word, "+s+", is not a palindrome.")   
                    
                    
                    
## EXERCISE / FINDING THE SUM OF TWO ELEMENTS IN TWO LISTS CLOSES TO A VALUE TARGET

            # TIME COMPLEXITY: O(nlogn)
            # SPACE COMPLEXITY: O(n)
            # a1 and a2 are the given lists, and target is the target sum.
            # The output should be a tuple of two integers, one from each array.
            def closest_sum_pair(a1, a2, target):
                a1_sorted = sorted(a1)
                a2_sorted = sorted(a2)
                i = 0
                j = len(a2_sorted) - 1
                smallest_diff = abs(a1_sorted[0] + a2_sorted[0] - target)
                closest_pair = (a1_sorted[0], a2_sorted[0])
                while i < len(a1_sorted) and j >= 0:
                    v1 = a1_sorted[i]
                    v2 = a2_sorted[j]
                    current_diff = v1 + v2 - target
                    if abs(current_diff) < smallest_diff:
                        smallest_diff = abs(current_diff)
                        closest_pair = (v1, v2)

                    if current_diff == 0:
                        return closest_pair
                    elif current_diff < 0:
                        i += 1
                    else:
                        j -= 1
                return closest_pair

            # NOTE: You can use the following values to test this function.
            a1 = [-1, 3, 8, 2, 9, 5]
            a2 = [4, 1, 2, 10, 5, 20]
            a_target = 24
            # closest_sum_pair(a1, a2, a_target) should return (5, 20) or (3, 20).

            b1 = [7, 4, 1, 10]
            b2 = [4, 5, 8, 7]
            b_target = 13
            # closest_sum_pair(b1, b2, b_target) should return (4,8), (7, 7), (7, 5), or (10, 4).

            c1 = [6, 8, -1, -8, -3]
            c2 = [4, -6, 2, 9, -3]
            c_target = 3
            # closest_sum_pair(c1, c2, c_target) should return (-1, 4) or (6, -3).

            d1 = [19, 14, 6, 11, -16, 14, -16, -9, 16, 13]
            d2 = [13, 9, -15, -2, -18, 16, 17, 2, -11, -7]
            d_target = -15
            # closest_sum_pair(d1, d2, d_target) should return (-16, 2) or (-9, -7).
                    
